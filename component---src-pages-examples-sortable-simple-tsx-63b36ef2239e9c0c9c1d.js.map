{"version":3,"sources":["webpack:///./src/examples/04 Sortable/Simple/ItemTypes.ts","webpack:///./src/examples/04 Sortable/Simple/Card.tsx","webpack:///./src/examples/04 Sortable/Simple/Container.tsx","webpack:///./src/examples/04 Sortable/Simple/index.tsx","webpack:///./src/pages/examples/sortable/simple.tsx","webpack:////Users/christrevino/Workspace/react-dnd/node_modules/immutability-helper/index.js"],"names":["ItemTypes","style","border","padding","marginBottom","backgroundColor","cursor","cardTarget","hover","props","monitor","component","dragIndex","getItem","index","hoverIndex","hoverBoundingRect","findDOMNode","getBoundingClientRect","hoverMiddleY","bottom","top","hoverClientY","getClientOffset","y","moveCard","Card","render","_this$props","this","text","isDragging","connectDragSource","connectDropTarget","opacity","react","Object","assign","React","DropTarget","connect","dropTarget","DragSource","beginDrag","id","dragSource","update","require","width","Container","_this","_React$Component","call","bind","assertThisInitialized_default","state","cards","_this2","map","card","i","Simple_Card","key","dragCard","setState","$splice","SortableSimple","href","Container_Container","__webpack_exports__","layout","Simple_SortableSimple","invariant","__webpack_require__","hasOwnProperty","prototype","splice","Array","toString","type","obj","slice","target","source","getAllKeys","forEach","getOwnPropertySymbols","keys","concat","copy","object","isArray","constructor","length","Map","Set","getPrototypeOf","create","newContext","commands","defaultCommands","extend","directive","fn","isEquals","a","b","spec","$apply","join","nextObject","objectWasNextObject","nextValueForKey","get","nextObjectValue","set","$push","value","invariantPushAndUnshift","$unshift","originalObject","invariantSplice","invariantSplices","args","apply","$set","invariantSet","$toggle","targets","invariantSpecArray","nextObjectCopy","$unset","$add","invariantMapOrSet","pair","has","add","$remove","delete","$merge","specValue","original","contextForExport","command","typeOfTarget","module","exports","default"],"mappings":"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","file":"component---src-pages-examples-sortable-simple-tsx-63b36ef2239e9c0c9c1d.js","sourcesContent":["export default {\n\tCARD: 'card',\n}\n","import * as React from 'react'\nimport { findDOMNode } from 'react-dom'\nimport {\n\tDragSource,\n\tDropTarget,\n\tConnectDropTarget,\n\tConnectDragSource,\n\tDropTargetMonitor,\n\tDropTargetConnector,\n\tDragSourceConnector,\n\tDragSourceMonitor,\n} from 'react-dnd'\nimport ItemTypes from './ItemTypes'\nimport { XYCoord } from 'dnd-core'\n\nconst style = {\n\tborder: '1px dashed gray',\n\tpadding: '0.5rem 1rem',\n\tmarginBottom: '.5rem',\n\tbackgroundColor: 'white',\n\tcursor: 'move',\n}\n\nconst cardSource = {\n\tbeginDrag(props: CardProps) {\n\t\treturn {\n\t\t\tid: props.id,\n\t\t\tindex: props.index,\n\t\t}\n\t},\n}\n\nconst cardTarget = {\n\thover(props: CardProps, monitor: DropTargetMonitor, component: Card | null) {\n\t\tif (!component) {\n\t\t\treturn null\n\t\t}\n\t\tconst dragIndex = monitor.getItem().index\n\t\tconst hoverIndex = props.index\n\n\t\t// Don't replace items with themselves\n\t\tif (dragIndex === hoverIndex) {\n\t\t\treturn\n\t\t}\n\n\t\t// Determine rectangle on screen\n\t\tconst hoverBoundingRect = (findDOMNode(\n\t\t\tcomponent,\n\t\t) as Element).getBoundingClientRect()\n\n\t\t// Get vertical middle\n\t\tconst hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2\n\n\t\t// Determine mouse position\n\t\tconst clientOffset = monitor.getClientOffset()\n\n\t\t// Get pixels to the top\n\t\tconst hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top\n\n\t\t// Only perform the move when the mouse has crossed half of the items height\n\t\t// When dragging downwards, only move when the cursor is below 50%\n\t\t// When dragging upwards, only move when the cursor is above 50%\n\n\t\t// Dragging downwards\n\t\tif (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {\n\t\t\treturn\n\t\t}\n\n\t\t// Dragging upwards\n\t\tif (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {\n\t\t\treturn\n\t\t}\n\n\t\t// Time to actually perform the action\n\t\tprops.moveCard(dragIndex, hoverIndex)\n\n\t\t// Note: we're mutating the monitor item here!\n\t\t// Generally it's better to avoid mutations,\n\t\t// but it's good here for the sake of performance\n\t\t// to avoid expensive index searches.\n\t\tmonitor.getItem().index = hoverIndex\n\t},\n}\n\nexport interface CardProps {\n\tid: any\n\ttext: string\n\tindex: number\n\tisDragging?: boolean\n\tconnectDragSource?: ConnectDragSource\n\tconnectDropTarget?: ConnectDropTarget\n\tmoveCard: (dragIndex: number, hoverIndex: number) => void\n}\n\nclass Card extends React.Component<CardProps> {\n\tpublic render() {\n\t\tconst {\n\t\t\ttext,\n\t\t\tisDragging,\n\t\t\tconnectDragSource,\n\t\t\tconnectDropTarget,\n\t\t} = this.props\n\t\tconst opacity = isDragging ? 0 : 1\n\n\t\treturn (\n\t\t\tconnectDragSource &&\n\t\t\tconnectDropTarget &&\n\t\t\tconnectDragSource(\n\t\t\t\tconnectDropTarget(<div style={{ ...style, opacity }}>{text}</div>),\n\t\t\t)\n\t\t)\n\t}\n}\n\nexport default DropTarget(\n\tItemTypes.CARD,\n\tcardTarget,\n\t(connect: DropTargetConnector) => ({\n\t\tconnectDropTarget: connect.dropTarget(),\n\t}),\n)(\n\tDragSource(\n\t\tItemTypes.CARD,\n\t\tcardSource,\n\t\t(connect: DragSourceConnector, monitor: DragSourceMonitor) => ({\n\t\t\tconnectDragSource: connect.dragSource(),\n\t\t\tisDragging: monitor.isDragging(),\n\t\t}),\n\t)(Card),\n)\n","import * as React from 'react'\nimport Card from './Card'\nconst update = require('immutability-helper')\n\nconst style = {\n\twidth: 400,\n}\n\nexport interface ContainerState {\n\tcards: Array<{\n\t\tid: number\n\t\ttext: string\n\t}>\n}\n\nexport default class Container extends React.Component<{}, ContainerState> {\n\tconstructor(props: {}) {\n\t\tsuper(props)\n\t\tthis.moveCard = this.moveCard.bind(this)\n\t\tthis.state = {\n\t\t\tcards: [\n\t\t\t\t{\n\t\t\t\t\tid: 1,\n\t\t\t\t\ttext: 'Write a cool JS library',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 2,\n\t\t\t\t\ttext: 'Make it generic enough',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 3,\n\t\t\t\t\ttext: 'Write README',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 4,\n\t\t\t\t\ttext: 'Create some examples',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 5,\n\t\t\t\t\ttext:\n\t\t\t\t\t\t'Spam in Twitter and IRC to promote it (note that this element is taller than the others)',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 6,\n\t\t\t\t\ttext: '???',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tid: 7,\n\t\t\t\t\ttext: 'PROFIT',\n\t\t\t\t},\n\t\t\t],\n\t\t}\n\t}\n\n\tpublic render() {\n\t\tconst { cards } = this.state\n\n\t\treturn (\n\t\t\t<div style={style}>\n\t\t\t\t{cards.map((card, i) => (\n\t\t\t\t\t<Card\n\t\t\t\t\t\tkey={card.id}\n\t\t\t\t\t\tindex={i}\n\t\t\t\t\t\tid={card.id}\n\t\t\t\t\t\ttext={card.text}\n\t\t\t\t\t\tmoveCard={this.moveCard}\n\t\t\t\t\t/>\n\t\t\t\t))}\n\t\t\t</div>\n\t\t)\n\t}\n\n\tprivate moveCard(dragIndex: number, hoverIndex: number) {\n\t\tconst { cards } = this.state\n\t\tconst dragCard = cards[dragIndex]\n\n\t\tthis.setState(\n\t\t\tupdate(this.state, {\n\t\t\t\tcards: {\n\t\t\t\t\t$splice: [[dragIndex, 1], [hoverIndex, 0, dragCard]],\n\t\t\t\t},\n\t\t\t}),\n\t\t)\n\t}\n}\n","import * as React from 'react'\nimport Container from './Container'\n\nexport default class SortableSimple extends React.Component {\n\tpublic render() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<p>\n\t\t\t\t\t<b>\n\t\t\t\t\t\t<a href=\"https://github.com/react-dnd/react-dnd/tree/master/packages/documentation/src/examples/04%20Sortable/Simple\">\n\t\t\t\t\t\t\tBrowse the Source\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</b>\n\t\t\t\t</p>\n\t\t\t\t<p>\n\t\t\t\t\tIt is easy to implement a sortable interface with React DnD. Just make\n\t\t\t\t\tthe same component both a drag source and a drop target, and reorder\n\t\t\t\t\tthe data in the <code>hover</code> handler.\n\t\t\t\t</p>\n\t\t\t\t<Container />\n\t\t\t</div>\n\t\t)\n\t}\n}\n","import * as React from 'react'\nimport Example from '../../../examples/04 Sortable/Simple'\nimport Layout from '../../../components/layout'\n\nexport default (props: any) => (\n\t<Layout {...props}>\n\t\t<Example />\n\t</Layout>\n)\n","var invariant = require('invariant');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar splice = Array.prototype.splice;\n\nvar toString = Object.prototype.toString\nvar type = function(obj) {\n  return toString.call(obj).slice(8, -1);\n}\n\nvar assign = Object.assign || /* istanbul ignore next */ function assign(target, source) {\n  getAllKeys(source).forEach(function(key) {\n    if (hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n};\n\nvar getAllKeys = typeof Object.getOwnPropertySymbols === 'function' ?\n  function(obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)) } :\n  /* istanbul ignore next */ function(obj) { return Object.keys(obj) };\n\n/* istanbul ignore next */\nfunction copy(object) {\n  if (Array.isArray(object)) {\n    return assign(object.constructor(object.length), object)\n  } else if (type(object) === 'Map') {\n    return new Map(object)\n  } else if (type(object) === 'Set') {\n    return new Set(object)\n  } else if (object && typeof object === 'object') {\n    var prototype = Object.getPrototypeOf(object);\n    return assign(Object.create(prototype), object);\n  } else {\n    return object;\n  }\n}\n\nfunction newContext() {\n  var commands = assign({}, defaultCommands);\n  update.extend = function(directive, fn) {\n    commands[directive] = fn;\n  };\n  update.isEquals = function(a, b) { return a === b; };\n\n  return update;\n\n  function update(object, spec) {\n    if (typeof spec === 'function') {\n      spec = { $apply: spec };\n    }\n\n    if (!(Array.isArray(object) && Array.isArray(spec))) {\n      invariant(\n        !Array.isArray(spec),\n        'update(): You provided an invalid spec to update(). The spec may ' +\n        'not contain an array except as the value of $set, $push, $unshift, ' +\n        '$splice or any custom command allowing an array value.'\n      );\n    }\n\n    invariant(\n      typeof spec === 'object' && spec !== null,\n      'update(): You provided an invalid spec to update(). The spec and ' +\n      'every included key path must be plain objects containing one of the ' +\n      'following commands: %s.',\n      Object.keys(commands).join(', ')\n    );\n\n    var nextObject = object;\n    var index, key;\n    getAllKeys(spec).forEach(function(key) {\n      if (hasOwnProperty.call(commands, key)) {\n        var objectWasNextObject = object === nextObject;\n        nextObject = commands[key](spec[key], nextObject, spec, object);\n        if (objectWasNextObject && update.isEquals(nextObject, object)) {\n          nextObject = object;\n        }\n      } else {\n        var nextValueForKey =\n          type(object) === 'Map'\n            ? update(object.get(key), spec[key])\n            : update(object[key], spec[key]);\n        var nextObjectValue =\n          type(nextObject) === 'Map'\n              ? nextObject.get(key)\n              : nextObject[key];\n        if (!update.isEquals(nextValueForKey, nextObjectValue) || typeof nextValueForKey === 'undefined' && !hasOwnProperty.call(object, key)) {\n          if (nextObject === object) {\n            nextObject = copy(object);\n          }\n          if (type(nextObject) === 'Map') {\n            nextObject.set(key, nextValueForKey);\n          } else {\n            nextObject[key] = nextValueForKey;\n          }\n        }\n      }\n    })\n    return nextObject;\n  }\n\n}\n\nvar defaultCommands = {\n  $push: function(value, nextObject, spec) {\n    invariantPushAndUnshift(nextObject, spec, '$push');\n    return value.length ? nextObject.concat(value) : nextObject;\n  },\n  $unshift: function(value, nextObject, spec) {\n    invariantPushAndUnshift(nextObject, spec, '$unshift');\n    return value.length ? value.concat(nextObject) : nextObject;\n  },\n  $splice: function(value, nextObject, spec, originalObject) {\n    invariantSplices(nextObject, spec);\n    value.forEach(function(args) {\n      invariantSplice(args);\n      if (nextObject === originalObject && args.length) nextObject = copy(originalObject);\n      splice.apply(nextObject, args);\n    });\n    return nextObject;\n  },\n  $set: function(value, nextObject, spec) {\n    invariantSet(spec);\n    return value;\n  },\n  $toggle: function(targets, nextObject) {\n    invariantSpecArray(targets, '$toggle');\n    var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;\n\n    targets.forEach(function(target) {\n      nextObjectCopy[target] = !nextObject[target];\n    });\n\n    return nextObjectCopy;\n  },\n  $unset: function(value, nextObject, spec, originalObject) {\n    invariantSpecArray(value, '$unset');\n    value.forEach(function(key) {\n      if (Object.hasOwnProperty.call(nextObject, key)) {\n        if (nextObject === originalObject) nextObject = copy(originalObject);\n        delete nextObject[key];\n      }\n    });\n    return nextObject;\n  },\n  $add: function(value, nextObject, spec, originalObject) {\n    invariantMapOrSet(nextObject, '$add');\n    invariantSpecArray(value, '$add');\n    if (type(nextObject) === 'Map') {\n      value.forEach(function(pair) {\n        var key = pair[0];\n        var value = pair[1];\n        if (nextObject === originalObject && nextObject.get(key) !== value) nextObject = copy(originalObject);\n        nextObject.set(key, value);\n      });\n    } else {\n      value.forEach(function(value) {\n        if (nextObject === originalObject && !nextObject.has(value)) nextObject = copy(originalObject);\n        nextObject.add(value);\n      });\n    }\n    return nextObject;\n  },\n  $remove: function(value, nextObject, spec, originalObject) {\n    invariantMapOrSet(nextObject, '$remove');\n    invariantSpecArray(value, '$remove');\n    value.forEach(function(key) {\n      if (nextObject === originalObject && nextObject.has(key)) nextObject = copy(originalObject);\n      nextObject.delete(key);\n    });\n    return nextObject;\n  },\n  $merge: function(value, nextObject, spec, originalObject) {\n    invariantMerge(nextObject, value);\n    getAllKeys(value).forEach(function(key) {\n      if (value[key] !== nextObject[key]) {\n        if (nextObject === originalObject) nextObject = copy(originalObject);\n        nextObject[key] = value[key];\n      }\n    });\n    return nextObject;\n  },\n  $apply: function(value, original) {\n    invariantApply(value);\n    return value(original);\n  }\n};\n\nvar contextForExport = newContext();\n\nmodule.exports = contextForExport;\nmodule.exports.default = contextForExport;\nmodule.exports.newContext = newContext;\n\n// invariants\n\nfunction invariantPushAndUnshift(value, spec, command) {\n  invariant(\n    Array.isArray(value),\n    'update(): expected target of %s to be an array; got %s.',\n    command,\n    value\n  );\n  invariantSpecArray(spec[command], command)\n}\n\nfunction invariantSpecArray(spec, command) {\n  invariant(\n    Array.isArray(spec),\n    'update(): expected spec of %s to be an array; got %s. ' +\n    'Did you forget to wrap your parameter in an array?',\n    command,\n    spec\n  );\n}\n\nfunction invariantSplices(value, spec) {\n  invariant(\n    Array.isArray(value),\n    'Expected $splice target to be an array; got %s',\n    value\n  );\n  invariantSplice(spec['$splice']);\n}\n\nfunction invariantSplice(value) {\n  invariant(\n    Array.isArray(value),\n    'update(): expected spec of $splice to be an array of arrays; got %s. ' +\n    'Did you forget to wrap your parameters in an array?',\n    value\n  );\n}\n\nfunction invariantApply(fn) {\n  invariant(\n    typeof fn === 'function',\n    'update(): expected spec of $apply to be a function; got %s.',\n    fn\n  );\n}\n\nfunction invariantSet(spec) {\n  invariant(\n    Object.keys(spec).length === 1,\n    'Cannot have more than one key in an object with $set'\n  );\n}\n\nfunction invariantMerge(target, specValue) {\n  invariant(\n    specValue && typeof specValue === 'object',\n    'update(): $merge expects a spec of type \\'object\\'; got %s',\n    specValue\n  );\n  invariant(\n    target && typeof target === 'object',\n    'update(): $merge expects a target of type \\'object\\'; got %s',\n    target\n  );\n}\n\nfunction invariantMapOrSet(target, command) {\n  var typeOfTarget = type(target);\n  invariant(\n    typeOfTarget === 'Map' || typeOfTarget === 'Set',\n    'update(): %s expects a target of type Set or Map; got %s',\n    command,\n    typeOfTarget\n  );\n}\n"],"sourceRoot":""}